<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Panorama</title>
    <style>
        /* Basic CSS to make the canvas fill the entire screen */
        body {
            margin: 0;
            overflow: hidden; /* Prevents scrollbars from appearing */
            font-family: 'Inter', sans-serif;
            background-color: #000;
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: block;
            cursor: grab;
        }
        #container:active {
            cursor: grabbing;
        }
        /* Simple loading overlay */
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            z-index: 10;
            transition: opacity 0.5s ease;
        }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <p>Loading 3D Scene...</p>
    </div>

    <div id="container"></div>

    <!-- Import Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- SCENE SETUP ---
        let scene, camera, renderer;
        let isUserInteracting = false;
        let onPointerDownMouseX = 0, onPointerDownMouseY = 0;
        let lon = 0, onPointerDownLon = 0;
        let lat = 0, onPointerDownLat = 0;
        let phi = 0, theta = 0;
        const clock = new THREE.Clock();
        const floatingObjects = []; // To store text and images for animation and interaction
        let particles, raycaster, mouse;
        let intersectedObject = null;

        // --- CUSTOMIZATION ---
        // Replace this with the path to your 360Â° panoramic image.
        const panoramaImageUrl = 'https://images.pexels.com/photos/167699/pexels-photo-167699.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=2';

        // Add or remove words to display. Now includes a 'color' property.
        const floatingWords = [
            { text: "Optimistic", position: { x: -20, y: 10, z: -35 }, color: 0xffd700 }, // Gold
            { text: "Creative", position: { x: 30, y: -2, z: -20 }, color: 0x9932cc }, // Dark Orchid
            { text: "Serene", position: { x: 28, y: 15, z: 25 }, color: 0x00bfff }, // Deep Sky Blue
            { text: "Dreamy", position: { x: -15, y: -12, z: 30 }, color: 0xdda0dd }, // Plum
            { text: "Vibrant", position: { x: -40, y: 0, z: 10 }, color: 0xff4500 }, // Orange Red
            { text: "Clarity", position: { x: 10, y: 2, z: 38 }, color: 0xf0f8ff }, // Alice Blue
            { text: "Sight", position: { x: -30, y: -15, z: -25 }, color: 0x7fffd4 }, // Aquamarine
            { text: "Wonder", position: { x: 5, y: 20, z: -10 }, color: 0x3cddc9 }, // Teal
            { text: "Peace", position: { x: 40, y: 5, z: 0 }, color: 0x98fb98 }, // Pale Green
        ];

        // Add or remove images to display.
        const floatingImages = [
            { src: 'img1.png', position: { x: 20, y: 8, z: -30 }, size: 12 },
            { src: 'img2.png', position: { x: -28, y: -8, z: 15 }, size: 15 },
            { src: 'img3.png', position: { x: 25, y: -15, z: 20 }, size: 10 },
            { src: 'img4.png', position: { x: -10, y: 18, z: 20 }, size: 11 },
            { src: 'img5.png', position: { x: 35, y: -10, z: 10 }, size: 13 },
            { src: 'img6.png', position: { x: -35, y: 5, z: -18 }, size: 14 },
            { src: 'img7.png', position: { x: 0, y: -18, z: -30 }, size: 12 },
        ];
        // -------------------

        init();
        animate();

        function init() {
            const container = document.getElementById('container');
            const loadingOverlay = document.getElementById('loading-overlay');

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1100);
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000104, 0.009);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 0).normalize();
            scene.add(directionalLight);

            const geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.scale(-1, 1, 1);

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(panoramaImageUrl, (texture) => {
                const material = new THREE.MeshBasicMaterial({ map: texture, fog: false });
                const backgroundSphere = new THREE.Mesh(geometry, material);
                backgroundSphere.renderOrder = -1;
                scene.add(backgroundSphere);
                loadingOverlay.style.opacity = '0';
                setTimeout(() => loadingOverlay.style.display = 'none', 500);
            });

            // --- Particle System ---
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCnt = 5000;
            const posArray = new Float32Array(particlesCnt * 3);
            for (let i = 0; i < particlesCnt * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * (Math.random() * 5) * 100;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMaterial = new THREE.PointsMaterial({ size: 0.05, color: 0xffffff });
            particles = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particles);

            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                floatingWords.forEach(wordObj => {
                    const textGeometry = new THREE.TextGeometry(wordObj.text, { font: font, size: 4, height: 1, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 5 });
                    const textMaterial = new THREE.MeshPhongMaterial({ color: wordObj.color, shininess: 90, transparent: true, opacity: 0.95, side: THREE.DoubleSide });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    textMesh.position.set(wordObj.position.x, wordObj.position.y, wordObj.position.z);
                    textGeometry.computeBoundingBox();
                    const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                    textMesh.position.x -= textWidth / 2;
                    scene.add(textMesh);
                    floatingObjects.push(textMesh);
                });
            });

            floatingImages.forEach(imageObj => {
                textureLoader.load(imageObj.src, (texture) => {
                    const imageGeometry = new THREE.PlaneGeometry(imageObj.size, imageObj.size);
                    const imageMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, opacity: 0.9 });
                    const imageMesh = new THREE.Mesh(imageGeometry, imageMaterial);
                    imageMesh.position.set(imageObj.position.x, imageObj.position.y, imageObj.position.z);
                    scene.add(imageMesh);
                    floatingObjects.push(imageMesh);
                });
            });

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            container.addEventListener('pointerdown', onPointerDown);
            container.addEventListener('pointermove', onPointerMove);
            container.addEventListener('pointerup', onPointerUp);
            container.addEventListener('wheel', onDocumentMouseWheel, { passive: false });
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            isUserInteracting = true;
            onPointerDownMouseX = event.clientX;
            onPointerDownMouseY = event.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;
        }

        function onPointerMove(event) {
            if (isUserInteracting === true) {
                lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
                lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
            }
        }

        function onPointerUp() {
            isUserInteracting = false;
        }

        function onDocumentMouseWheel(event) {
            const fov = camera.fov + event.deltaY * 0.05;
            camera.fov = THREE.MathUtils.clamp(fov, 10, 75);
            camera.updateProjectionMatrix();
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function checkIntersections() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(floatingObjects);

            if (intersects.length > 0) {
                if (intersectedObject !== intersects[0].object) {
                    // Reset previous object
                    if (intersectedObject) {
                        intersectedObject.scale.set(1, 1, 1);
                        if (intersectedObject.material.emissive) {
                            intersectedObject.material.emissive.setHex(0x000000);
                        }
                    }
                    // Set new intersected object
                    intersectedObject = intersects[0].object;
                    intersectedObject.scale.set(1.1, 1.1, 1.1);
                    if (intersectedObject.material.emissive) {
                        intersectedObject.material.emissive.setHex(0x555555);
                    }
                    document.body.style.cursor = 'pointer';
                }
            } else {
                // No intersections
                if (intersectedObject) {
                    intersectedObject.scale.set(1, 1, 1);
                    if (intersectedObject.material.emissive) {
                        intersectedObject.material.emissive.setHex(0x000000);
                    }
                }
                intersectedObject = null;
                document.body.style.cursor = 'grab';
            }
        }


        function animate() {
            requestAnimationFrame(animate);
            update();
        }

        function update() {
            const elapsedTime = clock.getElapsedTime();
            if (!isUserInteracting) {
                lon += 0.05; // Auto-rotate camera
            }

            particles.rotation.y = elapsedTime * 0.02;

            floatingObjects.forEach((obj, i) => {
                const speed = 0.5;
                obj.position.y += Math.sin(elapsedTime * speed + i) * 0.008;
                obj.position.x += Math.cos(elapsedTime * speed * 0.8 + i) * 0.004;
                obj.rotation.y += 0.0005;
                obj.rotation.x += 0.0002;
            });

            lat = Math.max(-85, Math.min(85, lat));
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);

            const x = 500 * Math.sin(phi) * Math.cos(theta);
            const y = 500 * Math.cos(phi);
            const z = 500 * Math.sin(phi) * Math.sin(theta);
            camera.lookAt(x, y, z);
            
            checkIntersections();
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

